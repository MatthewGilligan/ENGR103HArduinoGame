#include <Adafruit_CircuitPlayground.h> //libraries
#include <AsyncDelay.h>

AsyncDelay timer;
AsyncDelay levelTime;

const uint8_t spNEXT[]              PROGMEM ={0xAE,0xF6,0x16,0x3E,0x33,0x25,0x85,0xDA,0x5B,0x78,0x8F,0x34,0x5D,0xEA,0xE0,0x60,0x2C,0x5B,0xF6,0xA9,0x73,0xD6,0x50,0xED,0x3A,0xA7,0xCE,0x55,0x53,0x6C,0xEA,0x9E,0x3A,0x77,0x4D,0x8E,0x49,0x72,0x9A,0xDC,0x35,0xC4,0x37,0xC9,0x6C,0x52,0x53,0x2E,0xA9,0xF2,0x44,0x04,0x30,0xC0,0x91,0x51,0x06,0x78,0x29,0x42,0x03,0x12,0x90,0x00,0x08,0x60,0x04,0x55,0x02,0x9C,0xE0,0x82,0x81,0x07,0x00,0x00};

const uint8_t spGAMES[]             PROGMEM ={0xAA,0x15,0x24,0x2A,0xD6,0xE4,0xB6,0xB6,0x79,0x13,0xB1,0x5C,0xB2,0xF3,0x93,0x97,0xA4,0x66,0x3E,0x75,0x77,0x3E,0xF2,0x52,0x8D,0xCD,0x26,0xF6,0xCC,0x7B,0xDE,0x8A,0x9A,0x14,0x2D,0xBA,0xD2,0xAC,0x66,0xDD,0xEB,0xDE,0x8E,0xB6,0x7A,0x47,0x0D,0xAF,0x95,0x3A,0x6D,0xB1,0x9A,0xDA,0x8E,0xED,0x6C,0x67,0x3A,0x6E,0xA5,0x46,0x42,0xB1,0xED,0x74,0x27,0x3A,0x62,0x32,0xC2,0x23,0x76,0xEA,0x7F,0x22,0x36,0x11,0xF5,0x06,0x38,0x1C,0xC8,0x00,0xDF,0x29,0x39,0xE0,0x7B,0x56,0x03,0x7C,0xCD,0xCA,0x80,0xCC,0x83,0x1E,0x00,0x00};
const uint8_t spOVER[]              PROGMEM ={0xA7,0xD0,0xAE,0x2F,0x50,0xBA,0x9D,0x5C,0xDB,0xFA,0x24,0xCE,0x3A,0x72,0x19,0xFA,0x15,0x25,0x73,0xCB,0x45,0xAE,0x67,0xB4,0x2E,0xAD,0x10,0xB1,0x4E,0xC1,0x3D,0xB7,0x3A,0x1A,0x57,0x95,0x70,0xD4,0x9A,0x6C,0x4C,0x85,0xCD,0x4D,0xAF,0x5A,0xA5,0x7D,0x9A,0x9B,0xBB,0x1B,0x8D,0x69,0x66,0xE9,0xDC,0xAD,0xB5,0xA6,0x84,0xD8,0xA8,0xB6,0xD4,0xE9,0x2E,0x56,0x23,0x7E,0x42,0xAF,0xBB,0xC8,0x94,0x78,0x76,0xBD,0x99,0x2C,0x59,0xEC,0xCB,0xF5,0xB2,0x98,0x64,0xA6,0xE4,0x07,0x00,0x00};

uint32_t RED = CircuitPlayground.colorWheel(0);       // red
uint32_t BLUE = CircuitPlayground.colorWheel(160);    // blue




const int redPatterns[3][5] = { //alows for storing of patterns
  {1, 0, 1, 1, 0}, // Level 1
  {0, 1, 1, 1, 1}, // Level 2
  {1, 1, 0, 1, 0}  // Level 3
};

const int bluePatterns[3][5] = { //2d array
  {0, 1, 1, 0, 1}, // Level 1
  {1, 0, 1, 1, 0}, // Level 2
  {0, 1, 0, 1, 1}  // Level 3
};

int currentPosition = 0; //position in the array
int level = 1;
int score = 0; 

volatile bool button1 = false;
volatile bool button2 = false;

void setup() {
  Serial.begin(9600);
  CircuitPlayground.begin();

  timer.start(500, AsyncDelay::MILLIS); //500 ms between each update of the lights
  levelTime.start(30000, AsyncDelay::MILLIS); // 30 seconds per level

  attachInterrupt(digitalPinToInterrupt(4), button1ISR, FALLING); //interrupts on the main buttons
  attachInterrupt(digitalPinToInterrupt(5), button2ISR, FALLING);

  CircuitPlayground.clearPixels();
}

void loop() {
  if (!levelTime.isExpired()) { //if the level is still going on 

    if (timer.isExpired()) { //if the light timer expired
      CircuitPlayground.clearPixels(); //clear the pixels
      displayPattern(currentPosition); //update the pixels
      currentPosition = (currentPosition + 1) % 5; //shift currentPosition
      timer.restart(); //restart the timer
    }
    handleButtons(); //check the buttons
    } 
    else {
    // Advance to next level if available, otherwise game over
    if (level < 3) {
      level++;
      Serial.print("Level Up! Now on level ");
      Serial.println(level);
      levelTime.restart();
      currentPosition = 0;
      CircuitPlayground.clearPixels();
      delay(1500); //wait a bit so the player knows that the level is over
    } 
    else {
      // game Over
      Serial.println("Game Over");
      CircuitPlayground.speaker.say(spGAMES);
      CircuitPlayground.speaker.say(spOVER);
      CircuitPlayground.clearPixels();
      delay(1000000); // wait a super long time
    }
  }
}


void displayPattern(int pos) { //new display pattern function
  for (int i = 0; i < 5; i++) { //5 is the patternLength
    int pixelIndexRed = 4 - i; //make it so that the pixel lit up is the correct pixel. Make it correspond to 0-4
    if (redPatterns[level - 1][(pos + i) % 5]) { //5 is the length of the pattern
      CircuitPlayground.setPixelColor(pixelIndexRed, RED);
    }

    int pixelIndexBlue = 5 + i; //same thing but reversed for the 5-9
    if (bluePatterns[level - 1][(pos + i) % 5]) {
      CircuitPlayground.setPixelColor(pixelIndexBlue, BLUE);
    }
  }
}


void handleButtons() { //keeps track of the buttons and if they were pressed
  if (button1) {
    if (redPatterns[level - 1][(currentPosition - 1 + 5) % 5]) { //5 is the length of the pattern. //check if top is lit
      Serial.println("Red Scored!");
      CircuitPlayground.playTone(300, 100);
      score++;
    } else {
      score--;
    }
    button1 = false;
  }

  if (button2) {
    if (bluePatterns[level - 1][(currentPosition - 1 + 5) % 5]) { //check if top is lit (if the corresponding pin in the array is true)
      Serial.println("Blue Scored!");
      CircuitPlayground.playTone(600, 100);
      score++;
    } 
    else {
      score--;
    }
    button2 = false;
  }

  Serial.print("Level: ");
  Serial.print(level);
  Serial.print(" Score: ");
  Serial.println(score);
}

void button1ISR() {
  button1 = true;
}

void button2ISR() {
  button2 = true;
}
